namespace package.random.generator;

structure LinearCongruential {
    seed: u64,
    a: u64,
    b: u64,
    c: u64,
}

extends LinearCongruential {
    constructor(seed: u64?, a: u64 = 25214903917, b: u64 = 11, c: u64 = 2^48) {
        self.seed = seed ?? random_seed_safe();
        self.a = a;
        self.b = b;
        self.c = c;
    }
    random(mut self): u64 {
        self.seed = (self.a * self.seed + self.b) % self.c;
        self.seed
    }
}

extends XorShift {
    constructor(seed: u32?) {
        self.state = seed ?? random_seed_safe() as u32;
    }
    random(mut self): u32 {
        self.state.bit_xor_assign(self.state.bit_shift_left(13));
        self.state.bit_xor_assign(self.state.bit_shift_right(17));
        self.state.bit_xor_assign(self.state.bit_shift_left(5));
        self.state
    }
}

/// MT19937
structure MersenneTwister32 {
    seed: u64,
    index: u64,
    state: [u64; 624],
}
    
extends MersenneTwister32 {
    constructor(seed: u64?) {
        self.seed = seed ?? random_seed_safe();
        self.index = 0;
        self.state = [0; 624];
        self.state[0] = self.seed;
        for i in 1..624 {
            self.state[i] = 1812433253 * (self.state[i - 1] ^ (self.state[i - 1] >> 30)) + i;
        }
    }
    random(): u64 {
        if self.index == 0 {
            self.generate();
        }
        let mut y = self.state[self.index];
        y ^= y >> 11;
        y ^= (y << 7) & 2636928640;
        y ^= (y << 15) & 4022730752;
        y ^= y >> 18;
        self.index = (self.index + 1) % 624;
        y
    }
    sealed generate(): unit {
        for i in range(624) {
            let y = (self.state[i] & 16⁂80000000) + (self.state[(i + 1) % 624] & 16⁂7fffffff);
            self.state[i] = self.state[(i + 397) % 624] ^ (y >> 1);
            if y % 2 != 0 {
                self.state[i] ^= 16⁂9908b0df;
            }
        }
    }
}