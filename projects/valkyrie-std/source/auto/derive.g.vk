namespace package.auto;

macro derive {

}


























extends test AsyncTest {

    overload x(self) {

    }
    overload x(mut self) {

    }
    #test
    test_mut() {
        v = Vector2(1, 2)
        v.x()          // u64
        v.x().mutable; // &mut u64
    }
}


class AsyncTask {};



unite Poll[R, E] {
    ðŸ—¨ æ‰§è¡Œä¸­æˆ–æœªå¼€å§‹
    Pending,
    ðŸ—¨ å·²å®Œæˆçš„ä»»åŠ¡
    Fine {
        ðŸ—¨ æ‰§è¡Œå®Œæˆ, å†™å…¥ result åœ°å€
        result: T,
    },
    ðŸ—¨ è¢«å–æ¶ˆ, å¤±è´¥ç­‰æƒ…å†µ
    Fail {
        ðŸ—¨ æ‰§è¡Œå¤±è´¥, å†™å…¥ error åœ°å€
        error: E,
    },
}

std
ðŸ—¨ Î‘á¼°ÏŽÎ½, the default Global async
class singleton Aion {

}

ðŸ—¨ æ ‡è®°å¯ä»¥è°ƒç”¨ await çš„ç±»åž‹
trait Awaitable {
    type Return
    type Error

    poll(self, excutor: Excutor) -> Poll[Self::Return, Self::Error]

    #color(keyword)
    final await(self, excutor: Excutor = Aeon) -> Task[Self::Return] {
        self.poll(Aeon) as Task[Self::Return]
    }
    invoke(self) -> Task[Self::Return] {
        self.poll() as Task[Self::Return]
    }
}

extends Task: Awaitable {
    type Return = Unit;
    type Error = Unit;
}

extends Promise[T]: Awaitable {
    type Return = T;
    type Error = Unit;
}


extends test AsyncTask {
    overload read(file: File) -> Task[] {
        await block {
            print("async read: " + file.name)
        }
    }

    overload read(file: File) {
        print("sync read: " + file.name)
    }

    #test("test.txt")
    test_read(file) -> Task[] {
        // æ‰§è¡ŒåŒæ­¥ç‰ˆæœ¬(ç¼–è¯‘æ—¶å†…è”)
        read(file)
        // æ‰§è¡Œå¼‚æ­¥ç‰ˆæœ¬(ç¼–è¯‘æ—¶å†…è”)
        read(file).await;


        request.send().await?.text.json().await?

        await {
            try {
                request.send()?.text.json()?
            }
            .catch {

            }
        }
    }
}




micro await() {


    if (2000â„ƒ > 3000â„‰) {
        print("win win")
    }


}

extends Apply {
    invoke(self) {
        @await(self)
    }
}

