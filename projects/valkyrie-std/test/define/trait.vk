trait SemiGroup {
     combine(self, rhs: Self): Self;
}

trait Monoid: SemiGroup {
     unit();
}

forall T exists Option<T>: SemiGroup {
     combine(self, rhs: Self) = self.or(rhs)
}

forall T exists Option<T>: Monoid {
     unit() = None
}

trait HKT<U> {
    type Current;
    type Target;
}

trait Functor<B>: HKT<B> {
    forall F {F: Self::Current -> B}
    define fmap<F>(self, f: F) -> Self::Target
}

forall T, U exists Option<T>: HKT<U> {
    type Current = T;
    type Target = Option<U>;
}

forall A, B exists Option<A>: Functor<B> {
    forall F {F: A -> B}
    define fmap<F>(self, f: F) -> Self::Target {
        self.map(f)
    }
}

ğŸ—¨ é™æ€æ‰©å±•
trait extension Extension {
    match A {

    }
};

ğŸ—¨ å¯ä»¥è¿åçš„çº¦å®š
trait convention Extension {
    match A {

    }
};
